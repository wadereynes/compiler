/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.wade.model;

/**
 *
 * @author Gewa
 */

import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;

public class SyntaxAnalyzer {
    
    Token nextToken = null;
    
    JTree parseTree = null;
    DefaultMutableTreeNode nodeProgram = null;
    DefaultMutableTreeNode nodeStatement = null;
    DefaultMutableTreeNode nodeDeclarationStatement = null;
    DefaultMutableTreeNode nodeAssignmentStatement = null;
    DefaultMutableTreeNode nodeExpressionStatement = null;
    DefaultMutableTreeNode nodeIfStatement = null;
    DefaultMutableTreeNode nodeWhileStatement = null;
    DefaultMutableTreeNode nodeBooleanStatement = null;
    DefaultMutableTreeNode nodeTerm = null;
    DefaultMutableTreeNode nodeFactor = null;
    DefaultMutableTreeNode nodeLeaf = null;
    
    LexicalAnalyzer LA = null;
    
    SyntaxAnalyzer(String fileName) {
        
        LA = new LexicalAnalyzer(fileName);
    }
    
    public JTree getParseTree() {
        parseTree = new JTree(nodeProgram);
        return this.parseTree;
    }
    
    public void program() {
        System.out.println("Entered Program");
        
        nodeProgram = new DefaultMutableTreeNode("Program");
        
        nextToken = LA.lex();
        statement(nodeProgram);
        
        while(nextToken.getType() == Token.T_SEMICOLON) {
            nextToken = LA.lex();
            if (nextToken.getType() == Token.T_EOF) break;
            statement(nodeProgram);
        }
        if (nextToken.getType() != Token.T_EOF) {
            SyntaxAnalyzerDemo.showMessage("Statement should end with semicolon (;)");
            return;
        } 
        else {
            SyntaxAnalyzerDemo.showMessage("Parsing complete!");
        }
        
        System.out.println("Exited Program");
    }
    
    void statement(DefaultMutableTreeNode parent) {
        System.out.println("Entered Statement");
        
        nodeStatement = new DefaultMutableTreeNode("Statement");
        parent.add(nodeStatement);
        
        switch(nextToken.getType()) {
            
            case Token.T_INT:
            case Token.T_FLOAT:
                nextToken = LA.lex();
                declaration_statement(nodeStatement);
                break;
                
            case Token.T_IDENTIFIER:
                nextToken = LA.lex();
                assignment_statement(nodeStatement);
                break;
                
            case Token.T_IF_KEYWORD:
                nextToken = LA.lex();
                if_statement(nodeStatement);
                break;
                
            case Token.T_WHILE_KEYWORD:
                nextToken = LA.lex();
                while_statement(nodeStatement);
                break;
                
            default:
                parent.remove(nodeStatement);
                SyntaxAnalyzerDemo.showMessage("Syntax Analyzer: Illegal statement found!");
                //return;
        }
        
        System.out.println("Exited Statement");
    }
    
    /**
     * Function while statement ni wade ayaw kalimot
     * Parses string in the language generated by the rule
     */
    void while_statement(DefaultMutableTreeNode parent) {
        System.out.println("Entered While");
        
        nodeWhileStatement = new DefaultMutableTreeNode("While Statement");
        parent.add(nodeWhileStatement);
        
        if (nextToken.getType() == Token.T_OPENROUNDBRACKET) {
            
                nextToken = LA.lex();
                booleanExpression_Statement(nodeWhileStatement);
                
                if(nextToken.getType() == Token.T_CLOSEROUNDBRACKET) {
                        
                        nextToken = LA.lex();
                        if (nextToken.getType() == Token.T_OPENCURLYBRACKET) {
                            
                                nextToken = LA.lex();
                                statement(nodeWhileStatement);
                                
                                while (nextToken.getType() == Token.T_SEMICOLON) {
                                        nextToken = LA.lex();
                                        if (nextToken.getType() == Token.T_CLOSECURLYBRACKET) break;
                                        statement(nodeWhileStatement);
                                }
                                
                                if (nextToken.getType() == Token.T_CLOSECURLYBRACKET) {
                                         nextToken = LA.lex();
                                         //return;
                                }
                                else {
                                         SyntaxAnalyzerDemo.showMessage("Expected a '}' after  statements");
                                }
                        }
                        else {
                            SyntaxAnalyzerDemo.showMessage("Expected a '{' before statements");
                        }
                }
                else {
                    SyntaxAnalyzerDemo.showMessage("Expected a ')' before expression");
                }
        }
        else {
            SyntaxAnalyzerDemo.showMessage("Expected a ')' before expression");
        }
        
        System.out.println("Exited while");
    }
    
    /**
     *  Function if_statement ni wade
     *  Parses string in the language generated by the rule
     */
    
    void if_statement(DefaultMutableTreeNode parent) {
        System.out.println("Entered If");
        
        nodeIfStatement = new DefaultMutableTreeNode("IF Statement");
        parent.add(nodeIfStatement);
        
        if (nextToken.getType() == Token.T_OPENROUNDBRACKET) {
            
                   nextToken = LA.lex(); 
                   booleanExpression_Statement(nodeIfStatement);
                   
                   if (nextToken.getType() == Token.T_CLOSEROUNDBRACKET) {
                       
                             nextToken = LA.lex();
                             if (nextToken.getType() == Token.T_OPENCURLYBRACKET) {
                                 
                                    nextToken = LA.lex();
                                    statement(nodeIfStatement);
                                    
                                    while (nextToken.getType() == Token.T_SEMICOLON) {
                                            nextToken = LA.lex();
                                            if (nextToken.getType() == Token.T_CLOSECURLYBRACKET) break;
                                            statement(nodeIfStatement);
                                    }
                                    
                                    if (nextToken.getType() == Token.T_CLOSECURLYBRACKET) {
                                        nextToken = LA.lex();
                                        //return;
                                    }
                                    else {
                                            SyntaxAnalyzerDemo.showMessage("Expected a '}' after statements");
                                    }
                             }
                             else {
                                     SyntaxAnalyzerDemo.showMessage("Expected a '}' before statements");
                             }
                   }
                   else {
                           SyntaxAnalyzerDemo.showMessage("Expected a ')' after expression");
                   }
        }
        else {
               SyntaxAnalyzerDemo.showMessage("Expected a ')' after expression");
        }
        
        System.out.println("Exited if");
    }
    
    
    /**
     *  Function booleanExpressionStatement ni wade
     *  Parses the string of the language generated by the rule
     */
    
    void booleanExpression_Statement(DefaultMutableTreeNode parent) {
        System.out.println("Entered Boolean");
        
        nodeBooleanStatement = new DefaultMutableTreeNode("Boolean Expression");
        parent.add(nodeBooleanStatement);
        
        if (nextToken.getType() == Token.T_IDENTIFIER) {
                        
                    nextToken = LA.lex();
                    if (nextToken.getType() == Token.T_GREATERTHAN || nextToken.getType() == Token.T_LESSTHAN) {
                        
                                nextToken = LA.lex();
                                if (nextToken.getType() == Token.T_IDENTIFIER || nextToken.getType() == Token.T_FLOAT_NUMBER || nextToken.getType() == Token.T_INT_NUMBER) {
                                        nextToken = LA.lex();
                                        //return ;
                                }
                                else {
                                        SyntaxAnalyzerDemo.showMessage("Comparison should be made with Identifer or constant");
                                }
                    }
                    else {
                                SyntaxAnalyzerDemo.showMessage("A relational operator '>' or '<' is required");
                    }
        }
        else {
                SyntaxAnalyzerDemo.showMessage("Expected a boolean expression!");
        }
        
        System.out.println("Exited boolean");
        
    }
    
    /**
     * Function declaration_statement ni wade
     * Parses string in the language generated by the rule
     */
    void declaration_statement(DefaultMutableTreeNode parent) {
        System.out.println("Entered Declaration");
        
        nodeDeclarationStatement = new DefaultMutableTreeNode("Declaration");
        parent.add(nodeDeclarationStatement);
        
        if (nextToken.getType() == Token.T_IDENTIFIER) {
            nextToken = LA.lex();
            //return;
        }
        else {
            SyntaxAnalyzerDemo.showMessage("Not a valid identifier!");
        }
        
        System.out.println("Exited declaration");
    }
    
    /**
     * Function assingment_statement ni wade
     * Parses strings of the language generated by the rule
     */
    void assignment_statement(DefaultMutableTreeNode parent) {
         System.out.println("Entered Assignment");
         
         nodeAssignmentStatement = new DefaultMutableTreeNode("Assignment");
         parent.add(nodeAssignmentStatement);
         
         if (nextToken.getType() == Token.T_EQUALITYOP) {
                nextToken = LA.lex();
                expression_statement(nodeAssignmentStatement);
         }
         else {
                SyntaxAnalyzerDemo.showMessage("Expected a '=' operator");
         }
         
         System.out.println("Exited Program");
    }
    
    
    /**
     * Function expression_statement ni chiong
     * Parses string of the languages generated by the rule
     */
    void expression_statement(DefaultMutableTreeNode parent) {
        System.out.println("Entered Expression");
        
        nodeExpressionStatement = new DefaultMutableTreeNode("Expression");
        parent.add(nodeExpressionStatement);
        
        term(nodeExpressionStatement);
        
        while (nextToken.getType() == Token.T_PLUSOP || nextToken.getType() == Token.T_MINUSOP) {
                nodeLeaf = new DefaultMutableTreeNode(nextToken.getValue());
                nodeExpressionStatement.add(nodeLeaf);
                
                nextToken = LA.lex();
                term(nodeExpressionStatement);
        }
        
            System.out.println("Exited Expression");
        
    }
    
    /**
     * Function term ni chiong
     * Parses string of the languages generated by the rule
     */
    void term(DefaultMutableTreeNode parent) {
        System.out.println("Entered Term");
        
        nodeTerm = new DefaultMutableTreeNode("Term");
        parent.add(nodeTerm);
        
        factor(nodeTerm);
        
        while(nextToken.getType() == Token.T_MULOP || nextToken.getType() == Token.T_DIVOP) {
                    nodeLeaf = new DefaultMutableTreeNode(nextToken.getValue());
                    nodeTerm.add(nodeLeaf);
                    
                    nextToken = LA.lex();
                    factor(nodeTerm);
        }
        
        System.out.println("Exited Term");
    }
    
    /**
     * Function term ni chiong
     * Parses string of the languages generated by the rule
     */
    
     void factor(DefaultMutableTreeNode parent) {
         System.out.println("Entered Factor");
         
         nodeFactor = new DefaultMutableTreeNode("Factor");
         parent.add(nodeFactor);
         
         if (nextToken.getType() == Token.T_FLOAT_NUMBER || nextToken.getType() == Token.T_INT_NUMBER || nextToken.getType() == Token.T_IDENTIFIER) {
             
             nodeLeaf = new DefaultMutableTreeNode(nextToken.getValue());
             nodeFactor.add(nodeLeaf);
             
             nextToken = LA.lex();
             //return;
         }
         else {
             SyntaxAnalyzerDemo.showMessage("Syntax Analyzer: Invalid assingment made to identifier");
         }
         
         System.out.println("Exited Factor");
     }
    
}
